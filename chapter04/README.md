<details>
<summary>목차</summary>

- 📗 Chapter04. http 모듈로 서버 만들기 [🔗](#-chapter04-http-모듈로-서버-만들기)
  - 📖 4.1 요청과 응답 이해하기 [🔗](#-요청과-응답-이해하기)
  - 📖 4.2 REST와 라우팅 사용하기 [🔗](#-REST와-라우팅-사용하기)
  - 📖 4.3 쿠키와 세션 이해하기 [🔗](#-쿠키와-세션-이해하기)
  - 📖 4.4 https와 http2 [🔗](#-https와-http2)
  - 📖 4.5 cluster [🔗](#-cluster)

</details>

## 📗 Chapter04. http 모듈로 서버 만들기

실제 서버에서 필요한 쿠키와 세선 처리, 요청 주소별 라우팅 방법

### 📖 4.1 요청과 응답 이해하기

- 클라이언트에서 서버로 요청(request)를 보내고, 서버에서는 요청의 내용을 읽고 처리한 뒤 클라이언트에 응답(response)을 보낸다.
- 서버에서는 요청을 받는 부분과 응답을 보내는 부분이 있어야 한다.
- 요청과 응답은 이벤트 방식이라고 생각하면 된다.
- 클라이언트로부터 요청이 왔을 때 어떤 작업을 수행할지 이벤트 리스너를 미리 등록해두어야 한다.

> **localhost와 포트**
>
> **localhost**는 현재 컴퓨터의 내부 주소를 가리킨다. 외부에서 접근할 수 없고 자신의 컴퓨터에서만 접근할 수 있으므로, 서버 개발 시 테스트용으로 사용된다. localhost 대신 127.0.0.1을 주소로 사용해도 같다. 이러한 숫자 주소를 IP(Internet Protocol)이라고 부른다.
>
> **포트**는 서버 내에서 프로세스를 구분하는 번호이다. 서버는 HTTP 요청을 대기하는 것 외에도 다양한 작업을 한다. 데이터베이스와도 통신해야 하고, FTP 요청을 처리하기도 한다. 따라서 서버는 프로세스에 포트를 다르게 할당하여 들어오는 요청을 구분한다. 대표적인 포트 번호는 21(FTP), 80(HTTP), 443(HTTPS), 3306(MYSQL)이 있다. 포트 번호는 IP 주소 뒤에 콜론(:)과 함께 붙여 사용한다. 80(HTTP) 포트, 443(HTTPS) 포트의 경우 주소에서 생략할 수 있다.
>
> 리눅스와 맥에서는 1024번 이하의 포트에 연결할 때 관리자 권한을 필요로 한다.

> **소스 코드 번경**  
> 서버의 소스 코드를 변경할 때 서버가 자동으로 변경 사항을 반영하지 않는다. 서버를 종료했다가 다시 실행해야 변경 사항이 반영된다.  
> `nodemon`을 설치하여 변경 사항이 자동으로 반영되도록 설정할 수 있다.

> **HTTP 상태 코드**  
> 200, 500과 같은 숫자는 HTTP 상태 코드이다. 브라우저는 서버에서 보내주는 상태 코드를 보고 요청이 성공했는지 실패했는지 판단한다.
>
> - **2xx:** 성공을 알리는 상태 코드이다.
> - **3xx:** 리다이렉션(다른 페이지로 이동)을 알리는 상태 코드이다.
> - **4xx:** 요청 오류를 나타내는 상태 코드이다. 대표적으로 400(잘못된 요청), 401(권한 없음), 403(금지됨), 404(찾을 수 없음)가 있다.
> - **5xx:** 서버 오류를 나타내는 상태 코드이다. 요청은 제대로 왔으나 서버에 오류가 생겼을 때 발생한다. 500(내부 서버 오류), 502(불량 게이트웨이), 503(서비스를 사용할 수 없음)
>
> 요청 처리 과정 중에 에러가 발생했다고 해서 응답을 보내지 않으면 안 된다. 요청이 성공했든 실패했든 응답을 클라이어트로 보내서 요청이 마무리되었음을 반드시 알려야 한다. 응답을 보내지 않는다면, 클라이언트는 서버로부터 응답이 오길 하염없이 기다리다가 일정 시간 후 Timeout(시간 초과) 처리한다.

### 📖 4.2 REST와 라우팅 사용하기

- REST는 REpresentational State Transfer의 줄임말이며, 서버의 자원을 정의하고 자원에 대한 주소를 지정하는 방법을 가리킨다. 일종의 약속이다. 여기서 자원은 서버가 행할 수 있는 것들을 통틀어서 의미한다고 보면 된다.
- RESTful은 REST를 따르는 서버를 `RESTful하다`고 표현한다.
- 주소는 의미를 명확히 전달하기 위해 명사로 구성한다. 예를 들어 `/post`는 게시글에 관련된 자원을 요청하는 것이라고 추측할 수 있다.
- REST는 주소 외에도 HTTP 요청 메소드라는 것을 사용한다.
- 주소와 메서드만 보고 요청의 내용을 알아볼 수 있는 장점이 있다.
- GET 메서드의 경우 서버에서 가져오는 것이 아니라 브라우저에서 캐싱할 수도 있다. 캐싱이 되면 성능이 좋아진다.
- HTTP 통신을 사용하면 클라이언트와 상관없이 같은 방식으로 서버와 소통할 수 있다. 즉, 서버와 클라이언트가 분리되어 있다는 뜻이다.

> **HTTP 요청 메소드**  
> HTTP 요청 메소드에는 GET, POST, PATCH, PUT, DELETE, OPTIONS 등이 있다.
>
> - **GET:** 서버 자원을 가져오고자 할 때 사용한다. Request body에 데이터를 넣지 않는다. 데이터를 서버로 보내야 한다면 querystring을 사용한다.
> - **POST:** 서버에 자원을 새로 등록하고자 할 때 사용한다. Request body에 새로 등록할 데이터를 넣어 보낸다.
> - **PUT:** 서버의 자원을 요청에 들어있는 자원으로 치환하고자 할 때 사용한다. Request body에 치환할 데이터를 넣어 보낸다.
> - **PATCH:** 서버 자원의 일부만 수정하고자 할 때 사용한다. Request body에 일부 수정할 데이터를 넣어 보낸다.
> - **DELETE:** 서버의 자원을 삭제하고자 할 때 사용한다. Request body에 데이터를 넣지 않는다.
> - **OPTIONS:** 요청을 하기 전에 통신 옵션을 설명하기 위해 사용한다.

- 서버를 구축하고 브라우저 개발자모드의 **Network** 탭에서 네트워크 요청 내용을 실시간으로 볼 수 있다. REST 방식으로 주소를 만들었기 때문에 주소와 메서드만 보고 요청 내용을 유추할 수 있다.

### 📖 4.3 쿠키와 세션 이해하기

- 클라이언트에서 보내는 요청의 단점은 바로 누가 요청을 보냈는지 모른다는 것이다. 이때 누구인지 기억하기 위해 서버는 요청에 대한 응답을 할 때 쿠키라는 것을 같이 보낸다.
- 서버로부터 쿠키가 오면 웹 브라우저는 쿠키를 저장해두었다가 다음 요청에 쿠키를 동봉해서 보낸다. 서버는 요청에 들어있는 쿠키를 읽어서 사용자가 누구인지 파악한다.
- 브라우저는 쿠키가 있다면 자동으로 동봉해서 보내주므로 따로 처리할 필요가 없다. 서버에서 브라우저로 쿠키를 보낼 때만 코드를 직접 작성하여 처리해야 한다.
- 즉, 서버는 미리 클라이언트에 요청자를 추정할 만한 정보를 쿠키로 만들어 보내고, 클라이언트로부터 쿠키를 받아 요청자를 파악한다. 쿠키는 요청자가 누구인지 추적하고 있는 것이다. 개인정보 유출 방지를 위해 쿠키를 주기적으로 지우라고 권고하는 것은 바로 이러한 이유 때문이다.
- 쿠키는 서버에서 Request header에 `'Set-cookie': 'mycookie=test'`를 담아 요청자의 브라우저로 전송한다.

> - **쿠키명=쿠키값:** 기본적인 쿠키의 값이다.
> - **Expires=날짜:** 만료 기한이다. 이 기한이 지나면 쿠키가 제거됩니다. 기본값은 클라이언트가 종료될 때까지이다.
> - **Max-age=초:** Expires와 비슷하지만 날짜 대신 초를 입력할 수 있다. 해당 초가 지나면 쿠키가 제거된다. Expires보다 우선한다.
> - **Domain=도메인명:** 쿠키가 전송될 도메인을 특정할 수 있다.
> - **Path=URL:** 쿠키가 전송될 URL을 특정할 수 있다.
> - **Secure:** HTTPS일 경우에만 쿠키가 전송된다.
> - **HttpOnly:** 설정 시 자바스크립트에서 쿠키에 접근할 수 없습니다. 쿠키 조작을 방지하기 위해 설정하는 것이 좋다.

- 서버에 사용자 정보를 저장하고 클라이언트와 세션 아이디로만 소통하는 방식이 세션이다. 세션을 위해 사용하는 쿠키를 세션 쿠키라고 부른다.
- 실제 배포용 서버에서는 세션을 변수에 저장하지 않는다. 서버가 멈추건나 재시작되면 메모리에 저장된 변수가 초기화되기 때문이다. 보통은 레디스나 맴캐시드 같은 데이터베이스에 넣어둡니다.

### 📖 4.4 https와 http2

**https**

- https 모듈은 웹 서버에 SSL 암호화를 추가한다.
- GET이나 POST 요청을 할 때 오가는 데이터를 암호화해서 중간에 다른 사람이 요청을 가로채더라도 내용을 확인할 수 없게 한다.
- 로그인이나 결제가 필요한 창에서 https 적용이 필수가 되는 추세이다.
- 암호화를 적용하는 만큼 그것을 인증해줄 수 있는 기관도 필요하며, 인증 기관에서 구입하고 발급 과정도 복잡하다.

**http2**

- http2 모듈은 SSL 암호화와 더불어 최신 HTTP 프로토콜인 http/2를 사용할 수 있게 한다. 요청 및 응답 방식이 기존 http/1.1보다 개선되어 훨씬 효율적으로 요청을 보내기 때문에 웹의 속도도 많이 개선된다.

### 📖 4.5 cluster

- cluster 모듈은 기본적으로 싱글 프로세스로 동작한는 노드가 CPU 코어를 모두 사용할 수 있도록 해주는 모듈이다.
- 포트를 공유하는 노드 프로세스를 여러 개 둘 수도 있으므로, 요청이 많이 들어왔을 때 병렬로 실행된 서버의 개수만큼 요청이 분산되게 할 수 있다. 즉, 서버에 무리가 덜 가게 된다.
- 예를 들어 코어가 8개인 서버가 있을 때, 노드는 보통 코어를 하나만 활용한다. 하지만 cluster 모듈을 설정하여 코어 하나당 노드 프로세스 하나가 돌아가게 할 수 있다.
- 단점으로는 메모리를 서로 공유하지 못한다.

> **클러스터링**  
> `마스터 프로세스`가 요청을 받고 `워커 프로세스`들에게 일을 분배한다. 실질적인 일은 워커 프로세스가 하게 된다. 코어 개수에 맞게 워커 프로세스가 생성된다. 예기치 못한 에러로 인해 서버가 종료되는 현상을 방지할 수 있기 때문에 클러스터링을 적용해두는 것이 좋다. 클러스터링을 적용하면 오류 발생으로 워커 프로세스가 종료되어도 새로운 워커 프로세스를 생성하도록 하여 오류를 처리할 수 있으나, 이러한 방식은 근본적인 원인을 찾아 해결하는 것이 아니기 때문에 좋지 않은 방법이다.

- 직접 cluster 모듈로 클러스터링을 구현할 수도 있지만, 실무에서는 pm2 등의 모듈로 cluster 기능을 사용한다.
